<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Grotsky Part 1: Syntax | mliezun.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Grotsky Part 1: Syntax" />
<meta name="author" content="Miguel Liezun" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Part 1 of building my own laguage series. Defining the syntax of grotsky toy language." />
<meta property="og:description" content="Part 1 of building my own laguage series. Defining the syntax of grotsky toy language." />
<meta property="og:site_name" content="mliezun.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-02-21T00:00:00-03:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","author":{"@type":"Person","name":"Miguel Liezun"},"headline":"Grotsky Part 1: Syntax","dateModified":"2020-02-21T00:00:00-03:00","datePublished":"2020-02-21T00:00:00-03:00","description":"Part 1 of building my own laguage series. Defining the syntax of grotsky toy language.","url":"/2020/02/21/grotsky-part1.html","mainEntityOfPage":{"@type":"WebPage","@id":"/2020/02/21/grotsky-part1.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=40c55cb07623ae83d212bbbbe7d0dc4054666cf5">
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="/">mliezun.github.io</a></h1>
        
        

        <p></p>

        
        <p class="view"><a href="https://github.com/mliezun/mliezun.github.io">View the Project on GitHub <small>mliezun/mliezun.github.io</small></a></p>
        

        

        
      </header>
      <section>

      <small>21 February 2020</small>
<h1>Grotsky Part 1: Syntax</h1>

<p class="view">by Miguel Liezun</p>

<h3 id="syntax-restrictions">Syntax Restrictions</h3>

<ul>
  <li>No use of semicolon <code class="language-plaintext highlighter-rouge">;</code></li>
  <li>Block statements delimited by <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code></li>
  <li>Function definition using <code class="language-plaintext highlighter-rouge">fn</code> keyword</li>
  <li>Logic operators in plain english <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">not</code></li>
  <li>Conditional statements use the following keywords: <code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">elif</code>, <code class="language-plaintext highlighter-rouge">else</code></li>
  <li>There is no switch statement</li>
  <li>Class definition with <code class="language-plaintext highlighter-rouge">class</code> keyword</li>
  <li>Arithmetic operations: <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">^</code></li>
  <li>Grouping with parentheses <code class="language-plaintext highlighter-rouge">()</code></li>
  <li>Native support for python-like lists and dictionaries: <code class="language-plaintext highlighter-rouge">[]</code>, <code class="language-plaintext highlighter-rouge">{}</code></li>
  <li>Support for enhanced for loop: <code class="language-plaintext highlighter-rouge">for i, el in array</code></li>
  <li>Keywords and identifiers can only use alphabethic characters</li>
</ul>

<h3 id="primitives">Primitives</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">nil</code></li>
  <li>Integers</li>
  <li>Floats</li>
  <li>Booleans</li>
  <li>Strings</li>
  <li>Lists</li>
  <li>Dictionaries</li>
</ul>

<h3 id="example-of-functions-and-operations">Example of functions and operations</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## Arithmethic</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">10</span> <span class="o">-</span> <span class="mi">2323</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># Output: -5945</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">400</span><span class="o">/-</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">5</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="c1"># Output: 1.8189894035458565e-12</span>

<span class="c1">## Logic</span>
<span class="nb">print</span><span class="p">(</span><span class="kp">true</span> <span class="n">or</span> <span class="kp">false</span><span class="p">)</span>
<span class="c1"># Output: true (short circuit)</span>
<span class="nb">print</span><span class="p">(</span><span class="kp">false</span> <span class="n">and</span> <span class="kp">true</span><span class="p">)</span>
<span class="c1"># Output: false (short circuit)</span>

<span class="c1">## Conditionals</span>
<span class="k">if</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="n">or</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="n">and</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="k">begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Condition is true'</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">elif</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">4</span> <span class="k">begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Condition 2 is true'</span><span class="p">)</span>
<span class="k">end</span>
<span class="k">else</span> <span class="k">begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Conditions are false'</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">## Lists</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">let</span> <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="c1"># Output: [-1, 2, 3, 4]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># Output: [2, 3]</span>

<span class="c1">## Dictionaries</span>
<span class="c1"># (dictionaries and lists not allowed as keys)</span>
<span class="n">let</span> <span class="n">dct</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"Key1"</span><span class="p">:</span> <span class="s2">"Val1"</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="s2">"Val2"</span><span class="p">,</span>
    <span class="ss">true: </span><span class="kp">false</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="k">in</span> <span class="n">dct</span> <span class="k">begin</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">## Functions</span>
<span class="n">fn</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">begin</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span>
<span class="k">end</span>

<span class="n">fn</span> <span class="n">operate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">operation</span><span class="p">)</span>
<span class="k">begin</span>
    <span class="k">return</span> <span class="n">operation</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">## Clojure</span>
<span class="n">fn</span> <span class="n">makeCounter</span><span class="p">()</span>
<span class="k">begin</span>
    <span class="n">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">fn</span><span class="p">()</span> <span class="k">begin</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c1">## Classes</span>
<span class="k">class</span> <span class="nc">Counter</span>
<span class="k">begin</span>
    <span class="n">init</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="k">begin</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">start</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">end</span>
    <span class="n">count</span><span class="p">()</span> <span class="k">begin</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">start</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">start</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nf">start</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CounterTwo</span>
<span class="k">begin</span>
    <span class="n">count</span><span class="p">()</span> <span class="k">begin</span>
        <span class="k">return</span> <span class="k">super</span><span class="p">.</span><span class="nf">count</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="syntax-definition">Syntax definition</h3>

<p>Let’s build a syntax definition in backus naur format that will be easy to parse with a recursive descent parser.</p>

<h4 id="expresions">Expresions</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>expression      → assignment;
list            → "[" arguments? "]";
dictionary      → "{" dict_elements? "}";
dict_elements   → keyval ("," keyval)*;
keyval          → expression ":" expression;
assignment      → (call ".")? IDENTIFIER "=" assignment | access;
access          → logic_or ("[" slice "]")*;
logic_or        → logic_and ("or" logic_and)*;
logic_and       → equality ("and" equality)*;
equality        → comparison (("!=" | "==") comparison)*;
comparison      → addition (("&gt;" | "&gt;=" | "&lt;" | "&lt;=") addition)*;
addition        → multiplication (("-" | "+") multiplication)*;
multiplication  → power (("/" | "*") power)*;
power           → unary ("^" unary)*;
unary           → ("not" | "-") unary | call;
call            → primary ("(" arguments? ")" | "." IDENTIFIER)*;
arguments       → expression ("," expression)*;
slice           → (":" expression)
                | (":" expression ":" expression)
                | (":" ":" expression)
                | expression
                | (expression ":")
                | (expression ":" expression)
                | (expression ":" ":" expression)
                | (expression ":" expression ":" expression);
primary         → NUMBER
                | STRING
                | "false"
                | "true"
                | "nil"
                | IDENTIFIER
                | "(" expression ")"
                | fnAnon
                | list
                | dictionary;
fnAnon          → "fn" "(" parameters? ")" block;
</code></pre></div></div>

<h4 id="statements">Statements</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>program        → declaration* EOF;
declaration    → classDecl | funDecl | varDecl | statement;
classDecl      → "class" IDENTIFIER ( "&lt;" IDENTIFIER )? "begin" methodDecl* "end" NEWLINE;
methodDecl     → "class"? function;
funDecl        → "fn" function ;
function       → IDENTIFIER "(" parameters? ")" block ;
parameters     → IDENTIFIER ( "," IDENTIFIER )* ;
varDecl        → "let" IDENTIFIER ("=" expression)? NEWLINE;
statement      → forStmt
                | ifStmt
                | returnStmt
                | whileStmt
                | exprStmt;
exprStmt       → expression NEWLINE;
forStmt        → "for"  (classicFor | newFor) statement;
classicFor     → (varDecl | exprStmt | ",") expression? "," expression?;
newFor         → IDENTIFIER ("," IDENTIFIER)? "in" expression;
ifStmt         → "if" expression statement ("elif" expression statement)* ("else" statement)?;
returnStmt     → "return" expression? NEWLINE;
whileStmt      → "while" expression statement;
block          → "begin" NEWLINE declaration* "end" NEWLINE;
</code></pre></div></div>

<p>That’s it! The next step is to build a lexer and a parser.</p>



  <small>tags: <em>parser,lexer,interpreter</em></small>



      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/mliezun">mliezun</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    
  </body>
</html>
