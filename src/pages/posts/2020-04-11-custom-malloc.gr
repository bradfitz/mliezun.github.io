
let base = import("../base.gr")

# Create new Post Object
let post = base.Post(
    "Writing your own C malloc and free",
    "Challenge for writing your own implementation of malloc and free.",
    "Miguel Liezun",
    ["malloc", "free", "tutorial"],
    [
    [
        "h2",
        [],
        "Writing your own C malloc and free"
    ],
    [
        "div",
        [],
        "\n"
    ],
    [
        "h3",
        [],
        "Challenge"
    ],
    [
        "div",
        [],
        "\n"
    ],
    [
        "h3",
        [],
        "Solution"
    ],
    [
        "div",
        [],
        "\nThis challenge comes from the book Crafting Interpreters by Bob Nystrom. And can be found in [Chapter 14 - Challenge 3](http://www.craftinginterpreters.com/chunks-of-bytecode.html#challenges).\n\nThe challenge goes:\n\n> You are allowed to call malloc() once, at the beginning of the interpreters execution, to allocate a single big block of memory which your reallocate() function has access to. It parcels out blobs of memory from that single region, your own personal heap. Its your job to define how it does that.\n\n"
    ],
    [
        "h2",
        [],
        "define META_SIZE sizeof(struct block_meta)"
    ],
    [
        "div",
        [],
        "\nAs stated in the challenge I'll be using a big chunk of _contiguous_ memory. The main idea of my solution is to store the blocks of memory in the array prepending a header with metadata.\n\n```\n _______________________________________________\n|head_0|block_0 ... |head_1|block_1    ...      |\n \n```\n\nThe structure of the header is pretty similar to that of a linked list.\n\n```c\nstruct block_meta\n{\n    size_t size;\n    struct block_meta *next;\n    int free;\n};\n\n"
    ],
    [
        "h5",
        [],
        "Memory initialization"
    ],
    [
        "div",
        [],
        "```\n\nIt stores the size of the block, a pointer to the next block and a flag to mark wether it's free or not.\n\nThen, a function to traverse the list of blocks and find if there is any freed block is needed:\n\n```c\nvoid *first_block = NULL;\n\nstruct block_meta *find_free_block(struct block_meta **last, size_t size)\n{\n    struct block_meta *current = first_block;\n    while (current && !(current->free && current->size >= size))\n    {\n        *last = current;\n        current = current->next;\n    }\n    return current;\n}\n```\n\nThis function receives a double pointer to a block_meta struct called `last` that at the end of the execution should be pointing to the last node of the list and a size_t variable that indicates the minimum size that the block needs to be.\n\n"
    ],
    [
        "h2",
        [],
        "define MINREQ 0x20000"
    ],
    [
        "div",
        [],
        "\nTwo functions are needed to handle the big chunk of memory, one to initialize and the other to free it.\n\n```c\nvoid initMemory();\nvoid freeMemory();\n```\n\nTo implement `initMemory` I've decided that I would ask for the maximum amount of memory that I could get from the OS.\n\n```c\n"
    ],
    [
        "h3",
        [],
        "New challenge"
    ],
    [
        "div",
        [],
        "\n// Big block of memory\nvoid *memory = NULL;\n// Position where the last block ends\nsize_t endpos = 0;\n\nvoid initMemory()\n{\n    size_t required = PTRDIFF_MAX;\n    while (memory == NULL)\n    {\n        memory = malloc(required);\n        if (required < MINREQ)\n        {\n            if (memory)\n            {\n                free(memory);\n            }\n            printf(\"Cannot allocate enough memory\\n\");\n            exit(ENOMEM);\n        }\n        required >>= 1;\n    }\n}\n\nvoid freeMemory()\n{\n    free(memory);\n}\n```\n\nAs you can see, `initMemory` starts trying to allocate the maximum amount a memory allowed, and starts to divide that amount by 2 every time the allocation fails. If there isn't at least 128KB of memory available the program crashes with ENOMEM.\n\nNow that we have our chunk of memory ready to go, we can start to start giving blocks away.\n\n```c\nstruct block_meta *request_block(size_t size)\n{\n    struct block_meta *last = NULL;\n    struct block_meta *block = find_free_block(&last, size);\n    if (block)\n    {\n        block->free = 0;\n        return block;\n    }\n    // Append new block to list\n    block = memory + endpos;\n    endpos += META_SIZE + size;\n    if (last)\n    {\n        last->next = block;\n    }\n    else\n    {\n        first_block = block;\n    }\n    block->free = 0;\n    block->next = NULL;\n    block->size = size;\n    return block;\n}\n```\n\nHow `request_block` works:\n\n1. Tries to find a free block with enough space. If there is one, it is set as occupied and returns that block.\n2. If there isn't a free block available. It adds a new block with enough space at the end of `memory` (the big chunk).\n3. If this is the first call, points the head of the list to the recently created block, else point the last node to the block.\n4. Set the new block as occupied, set the size and next to null. Then return the new block.\n\nWith this function, implementing `malloc` and `free` is pretty easy:\n\n```c\nvoid *my_malloc(size_t size)\n{\n    struct block_meta *block = request_block(size);\n    return block + 1;\n}\n\nvoid my_free(void *ptr)\n{\n    struct block_meta *block = ptr - META_SIZE;\n    block->free = 1;\n}\n```\n\nTo finish the challenge, I have to implement realloc, that is a little bit more tricky.\n\n```c\nvoid *my_realloc(void *ptr, size_t size)\n{\n    if (!ptr)\n    {\n        return my_malloc(size);\n    }\n    struct block_meta *block = ptr - META_SIZE;\n    if (block->size >= size)\n    {\n        return block + 1;\n    }\n    uint8_t *newptr = my_malloc(size);\n    size_t i;\n    for (i = 0; i < (block->size < size ? block->size : size); i++)\n    {\n        newptr[i] = ((uint8_t *)ptr)[i];\n    }\n    block->free = 1;\n    return newptr;\n}\n```\n\nHow realloc works:\n\n- If the pointer to reallocate is null, works just like malloc.\n- If the given size is bigger than the prior size, it allocates a bigger block and copies all data from the original block to the new block.\n- If the given size is smaller than the prior size, it allocates a smaller block and copies just the data that fits into the smaller block.\n\n"
    ],
    [
        "h3",
        [],
        "Resources"
    ],
    [
        "div",
        [],
        "\nIn my implementation I used a linked list where each node holds a pointer to the next, but given that I have control over the _entire_ memory this actualy isn't necessary.\n\nMy challenge to you is that you remove the pointer to next from the `block_meta` struct.\n\n"
    ]
]
)
